# -*- coding: utf-8 -*-
import console, datetime, json, pprint, sys, time, Image, photos

'''
Questions:
    1. Are there any serious disadvantages from having the output of a task be a single dictionary that contains
       all observations?
    2. Will it be possible to store the outtput files in a dropbox folder?
    3. Is it better to build one application that does multiple tasks, or should tasks be separate? There is no
       real need for this application to be uploaded to the AppStore as I can personally load the code into
       Pythonista on the iPads that will be used by the observers (the teams are very small)
    4. Is there a more interesting interface that could be used? The console is fine, but its a bit uninspiring.
       Ideally after configuration the application would create a button for each operator which maps to some
       idea of the pysical reality of their location on the floor, and then when undertaking tasks the user would
       simply touch the button to initialise the prompts for information. This is especially the case for the
       interaction task (see readMe) 
    5. Whilst I do not want to allow the user to 'cancel' dialogue boxes (as they return KeyboardInterrupt) which
       will cause the program to crash, and I do not want them to be capable of being pressed by accident, I do
       want the user to be able to escape a task (and lose all accumulated data), if a task is entered accidentally.
       Is this achievable?
    6. I do not currently understand the main(argv) function, so I have left it blank for now and tried to write the
       routine in linear format I guess. What does the function do? Does it assist if the ipad 'home' button is
       pressed accidentally? This is something I will need to consider. I do not want to lose information as the
       user accidentally pressed the home button. I will try to brush up on what is going on here.  

    Development: I have taken on board the comments of CCC in trying to rework the application. There were a few
       coding aspects that I did not understand. I have left comments to that effect which are recognisable by a #!!
       prefix. 
'''
	
def get_timestamp(in_datetime = None):
    ''' Returns formatted date string '''

    in_datetime = in_datetime or datetime.datetime.now()
    return in_datetime.strftime('%Y_%m_%d_%H_%M')
    #!! I am unsure about line: `in_datetime = in_datetime or datetime.datetime.now()`. What is the meaning of 
    #   the 'or' here, why not just `datetime.datetime.now()` ?
    #ccc: If the caller does not provide a date then subsititute now() as the date provided

def get_user_choice_text(in_title, in_prompt_and_choices): 
    ''' Returns text of user choice '''
    #!! This has been extended to deal with the KeyboardInterrupt that is returned if 'cancel' is selected.
    #   Additionally it may now return either text or 
 	
    try:
        user_choice = in_prompt_and_choices[console.alert(in_title, *in_prompt_and_choices)]
	return user_choice
    except KeyboardInterrupt:
        pass
    Error = 'You may not cancel at this time'
    console.hud_alert(Error, 'error')
    return get_user_choice_text(in_title, in_prompt_and_choices)

def get_user_choice_num(in_title, in_prompt_and_choices, cancel = True):
    """ Returns number of user choice. If cancel = True then the user may cancel the dialogue, otherwise
        cancellations will be met with an hud error message """
    #¡¡ Possibly this function could be combined with the above i.e add an argument format = text/num. However,
    #   perhaps that is too messy. There is no need to allow the user to cancel the dialogues generated by the
    #   text version of this function (yet), so it is not added there. 
    if cancel:
        user_choice = console.alert(in_title, *in_prompt_and_choices)
        return user_choice
    try:
        user_choice = console.alert(in_title, *in_prompt_and_choices)
        return user_choice
    except KeyboardInterrupt:
		pass
    Error = 'You may not cancel at this time'
    console.hud_alert(Error, 'error')
    return get_user_choice_num(in_title, in_prompt_and_choices, cancel = False)

def get_user_int(in_prompt, in_min = 1, in_max = 100):
    ''' Helper function to prompt user to input an integer. Returns the verified integer'''
    #!! I was unsure of what the following code added to the keyword arguments so have left the code commented out
    #   for now:

    #(in_min, in_max) = (int(min(in_min, in_max)),
    #                    int(max(in_min, in_max)))
    #ccc: That code just verifies that both parameters are numbers and that min is <= max

    # The function has been extended to include dealing with KeyboardInterrupt and also to retun a hud message to
    # user when the input is incorrect. It has also been extended to confirm that the number entered is in fact an
    # integer rather than just capable of being an integer. 

    try:
        user_int = console.input_alert(in_prompt)
        if in_min <= int(user_int) <= in_max and float(user_int)%1 == 0:
            return int(user_int)
    except (ValueError, KeyboardInterrupt):
        pass
    Error = 'Error: Please enter a whole number between {} and {}'.format(in_min, in_max)
    console.hud_alert(Error, 'error')
    return get_user_int(in_prompt)

def get_user_Sfloat(in_prompt, in_min = 0.25, in_max = 48.0):
    ''' Helper function to prompt the user to enter a 'special' float. Returns the verified special float.
        Special in this instance means that the float is a multiple of 0.25'''
    # This is a new function in the style of get_user_int()

    try:
        user_Sfloat = console.input_alert(in_prompt)
        if float(in_min) <= float(user_Sfloat) <= in_max and float(user_Sfloat)%0.25 == 0:
            return float(user_Sfloat)
    except (ValueError, KeyboardInterrupt):
        pass
    Error = 'Error: Please enter a number beetween {} and {} that is a multiple of 0.25'.format(in_min, in_max)
    console.hud_alert(Error, 'error')
    return get_user_Sfloat(in_prompt)

def get_user_input(in_prompt, cancel = False):
    '''Returns user input'''
    if cancel:
        user_input = console.input_alert(in_prompt)
        return user_input
    try:
        user_input = console.input_alert(in_prompt)
        return user_input
    except KeyboardInterrupt:
		pass
	Error = 'You may not cancel at this time'
	console.hud_alert(Error, 'error')
    return get_user_input(in_prompt)

def get_user_approval(in_prompt):
    pass
    # I suspeect this can be achieved with get_user_choice_text()
    # Return to this if needed

def write_to_json(in_dict, file_name):
    ''' Function to save in_dict to json '''
    with open(file_name, 'w') as out_file:
        json.dump(in_dict, out_file)
    return

def open_json(file_name, function, f_args):
    ''' Function to open JSON. Returns json file if in directory else the function and arguments that will create
        the json'''	
    #!! The idea here is to look for the json file that is passed as the file_name argument and if it is not found
    #   in the working directory then the function that creates that file is invoked. For example, upon first using
    #   the application the Top Level Output is not yet in existence. When this is the case the routine for creating
    #   that will be invoked. I am tyring to be a bit more logical in the way I use these functions, but I'm not sure
    #   if this is the best way to go about doing it or not.

    try:
        out_dict = json.load(open(file_name))
	    return out_dict
    except IOError:
        return function(*f_args)

'''
The following task dictionary contains the names of the tasks that are envisaged (currently 3, although only one (wip)
is fully thought through at this stage). The tuple contains the json name in which data related to that task are/will
be stored, and a list of the variables that will be collected for each task.
'''

task_dict = {('Knitting_wip',      '11') : ('Knitting_wip.json',      ['Attendance', 'Style', 'WIP']),
             ('Linking_wip',       '12') : ('Linking_wip.json',       ['Attendance', 'Style', 'WIP']),
             ('Knitting_interact', '21') : ('Knitting_interact.json', ['enter_once_determined']),
             ('Linking_interact',  '22') : ('Linking_interact.json',  ['enter_once_determined']),
             ('Knitting_other',    '31') : ('Knitting_other.json',    ['enter_once_determined']),
             ('Linking_other',     '32') : ('Linking_other.json',     ['enter_once_determined'])}

def create_task_dicts(top_level_dict, task_dict):
    """ Function to create task dictionaries. This is designed to be called inside the configure application
        function. Saves each dict to .json """
    #!! This function seems a little erratic as it is based upon using sub-strings to determine how to create the
    #   dictionaries. It seems to work, but I am concerned that a small change in the strings entered either in the
    #   top_level_dict or the task_dict could prove fatal. At present this was the best I could come up with. Return
    #   at a later date perhaps. 
	
    for task in task_dict.keys():
        department = task[0].split('_')[0] 
        task_dict_json = {'date_time' : []}
        task_dict_json.update({department[:2].upper() + str(serial_no) :
                                  {variable : [] for variable in task_dict[task][1]}
		                       for serial_no in xrange(1, top_level_dict[department] + 1)})
        write_to_json(task_dict_json, task_dict[task][0])
        return

#A string that is used in the configure_appication function
#¡¡ What is the benfit of making this a global variable rather than one local to the function? It is purely a
#   cleanliness thing (i.e. to keep the function a bit tidier?). Also, why not pass it as an argument to the
#   function?

Top_validation_fmt = '''
You have entered the following data:
	
	'Knitting': 	{Knitting}
	'Linking' : 	{Linking}

Are you satisfied with this? '''

def configure_application(file_name):
    """ Creates and returns the top level dictionary and the task dictionaries. Additioanlly tests user satisfaction
        with the top level data entered and saves to json. It is intended that this is the function that is returned
        by the open_json function if the json does not already exist when opening the top_level_data."""
    #¡¡ I am not sure if this is really the right way to program these type of functions that return other functions.
    #   This seems to work, but doubtless there is some coding style best practice I have overlooked. 

    print 'First you need to conifgure the application for the number of operators to be observed'
    time.sleep(4)
	
    # create top level dictionary
    top_level_dict = { 'Knitting' : get_user_int('Please enter the number of Knitting Operators'),
                       'Linking'  : get_user_int('Please enter the number of Linking Operators') }

    print(Top_validation_fmt.format(**top_level_dict))  # print data back to user

    # check user satisfaction
    user_satisfied = get_user_choice_text('Are you satisfied with data entered?', 
	                                      ('Select one', 'Yes', 'No'))
    if user_satisfied == 'No':
        return configure_application(file_name)

    # save to json
    write_to_json(top_level_dict, file_name)

    # Create and save the task dictionaries
    create_task_dicts(top_level_dict, task_dict)

    return top_level_dict
	
def create_id_dicts(top_level_dict, department):
	""" Creates and returns the a worker ID dict. The entry for each machine code is a dict containing two
		keys, the first will map to a string equal either to 'Manned' or 'Unmanned, and the second will map to a
		string equal to the worker id number or null."""
	# This function will create empty id_dicts, I have not yet been able to test it. 	
	dept_choice = department
																  
	id_dict = 	{'date_time' : str()}
	id_dict.update(	{dept_choice[:2].upper() + serial_no : 
					{'mc_status' : str(), 'worker_id' : str()}
					for serial_no in xrange(1, top_level_dict[dept_choice] + 1)})
	
	return id_dict

def locate_most_recent(file_prefix):
	""" Function returns the most recent file that contains file_prefix if any exist"""	
	# This function will search for the most recent daily id dict. If there are none it returns None. I have not
	# had a chance to test it. 
	file_list = os.listdir(os.getcwd())
	prefix_file_list = [file for file in file_list if file_prefix in file]
	if not prefix_file_list:
		return None #Not sure about this yet, return to it.
	date_list = [date for date in [file.split('-')[1] for file in prefix_file_list] # Note the character on which to
																					#split the file name is currently '-'	
	datetime_list = [datetime.datetime.strptime(date, '%Y_%m_%d_%H_%M') for date in date_list]
	most_recent_date = max(datetime_list)
	most_recent_file = file_prefix + '-' + most_recent_date.strftime('%Y_%m_%d_%H_%M')
	return most_recent_file

ID_validation_fmt = '''
You have entered the following data:
	
	'Machine Status'	: 	{mc_status}
	'Worker ID' 		: 	{worker_id}

Are you satisfied with this? '''

ID_validation_fmt_2 = '''
The most recent available data for this machine are:
	
	'Machine Status'	: 	{mc_status}
	'Worker ID' 		: 	{worker_id}

Are you satisfied with this? '''

	
def worker_id(machine_code):
	""" Function prompts user for informaiton about the machine and the id of the operator working the machine
		(if any). Returns dict of that information"""
	# This generates the worker routine for an individual operator. Rather than thinking about present/absent
	# the user will simply state is the machine is manned or unmanned. If it is manned they will be prompted
	# to enter the worker id of the person working on the machine. The fact that manned/unmanned status will be
	# dealt with here means that the Attendance component of the wip task is now defunct (although the user may wish
	# to change the manned/unmanned status during the task if for example the worker was absent when the id routine
	# is run, but present once the wip task is undertaken. 
	console.clear()
	print('For machine {} please enter thee following information: \n'.format(machine_code))
	
	worker_id_dict = { 'mc_status' : 'Unmanned', 
					   'worker_id' : 'null'}
					   
	user_choice = get_user_choice_text('{} : Please state is machine is manned or unmanned?'.format(machine_code), 
	                                    ('Please select an option', 'Manned', 'Unmanned',))
	
	# If machine unmanned
    if user_choice != 'Manned':
         print ID_validation_fmt.format(machine_code, **worker_id_dict)  # print data back to user
         time.sleep(2)

		#check user satisfaction
		user_satisfied = get_user_choice_text('Are you satisfied with data entered?',
                                             ('Select one', 'Yes', 'No'))
		if user_satisfied == 'No':
			return worker_id(machine_code)  # re-enter the machine dict data

		return worker_id_dict  # return the machine dict
	
	worker_id_dict['mc_status'] = 'Manned'
	prompt = 'Please enter the id number of the worker on this machine as is appears on their ID card: '
    worker_id_dict['worker_id'] = get_user_input(prompt).strip().lower()
	print ID_validation_fmt.format(machine_code, **worker_id_dict) # print data back to user
    time.sleep(4)
	
    user_satisfied = get_user_choice_text('Are you satisfied with data entered?', 
	                                       ('Select one', 'Yes', 'No'))
    if user_satisfied == 'No':
        return worker_id(machine_code) #re-enter worker wip data
	
    return worker_id_dict #return the worker id dict
	
def create_machine_code(top_level_dict, department):
    """ Function returns a list of the worker codes. """
    #!! This is somewhat surplus to requirements. The issue is that running though the worker codes in the dictionary
    #   json presents the codes out of order. Perhaps an ordered dict could be used instead?

    return [department[:2].upper() + str(serial_no) for serial_no in xrange(1, top_level_dict[department] + 1)]
	
def populate_first_id_dict(id_dict, top_level_dict, department):
	""" Function to populate the worker id dicts for the first time """
	# If no daily_id dicts exist then this function will create the first instance of that dict by prompting user
	# user for the relevant informaiton by calling the worker_id function. I have not yet had the chance to see if 
	# this works. 
	id_dict['date_time'].append(get_timestamp())
	for machine_code in create_machine_code(top_level_dict, department):
		worker_id_dict = worker_id(machine_code)
		id_dict[machine_code]['mc_status'] = worker_id_dict['mc_status']
		id_dict[machine_code]['worker_id'] = worker_id_dict['worker_id']
	return id_dict
	
def populate_id_dict(id_dict, past_id_dict_file_name, top_level_dict, department):
	""" Function to populate worker id dicts based upon previous saved versions """
	# This function populates the daily id dict but rather than asking the user for each piece of information it
	# takes the last known data for that machine and prompts the user to see if they wish to make changes. If they 
	# do the the worker_id function is called. I have not yet had the chance to see if this is working. 
	if past_id_dict_file_name is None:
		return populate_first_id_dict(id_dict, top_level_dict, department)
	
	past_id_dict = open_json(past_id_dict_file_name, None, None)
	for machine_code in create_machine_code(top_level_dict, department):
		print ID_validation_fmt.format_2(machine_code, **past_id_dict[machine_code]) # print data back to user
		user_satisfied = get_user_choice_text('Are you satisfied with data entered?', 
											 ('Select one', 'Yes', 'No'))
		if user_satisfied == 'Yes':
			id_dict[machine_code]['mc_status'] = past_id_dict[machine_code]['mc_status']
			id_dict[machine_code]['worker_id'] = past_id_dict[machine_code]['worker_id']
		else:
			update_id_dict = worker_id(machine_code)
			id_dict[machine_code]['mc_status'] = update_id_dict['mc_status']
			id_dict[machine_code]['worker_id'] = update_id_dict['worker_id']
	return id_dict
	

def id_daily_routine(file_prefix, top_level_dict):
	""" Function that controls the id daily_routine"""
	# I worry that this is not very elegant, and I have not yet been able to test it. The idea is that this function
	# controls the entire routine of worker id. In particulatr I worry about all of the functions calling other
	# functions as part of this routine. It seems like the complexity might make the program hard to debug. 

	daily_file = locate_most_recent(file_prefix + '_id')
	if daily_file is None:
		return populate_id_dict(create_id_dicts(top_level_dict, file_prefix), daily_file, top_level_dict, file_prefix)
	if get_timestamp()[:10] not in daily_file:
		return populate_id_dict(create_id_dicts(top_level_dict, file_prefix), daily_file, top_level_dict, file_prefix)
	else:
		return open_json(daily_file, None, None)


def determine_task(user_task_dict = task_dict):
    ''' Function prompts user to determine which task is to be undertaken and return the key (a tuple) that relates
        to that task fom the task_dict'''
	
	task_choice = str(get_user_choice_num('Select a task', ('Please select a task to complete', 
	              									                        'Work in progress', 
	              									                        'Interactions',
	                      		      							          'Other')))
	#¡¡ This allows a cancel by the user, but it will crash the program, is that what I want? Not sure.
	
	dept_choice = str(get_user_choice_num('Select a department', ('Please select which department to work in',
	                          		                                'Knitting',
	                              		                            'Linking')))
	
	user_task_choice = task_choice + dept_choice
	
	for task_tuple in task_dict.keys():
		if user_task_choice in task_tuple: 
			return task_tuple


#A string that is used to display the wip data back to the user
wip_validation_fmt = ''' You have entered the following data for machine {}:
	
    'Attendance' : {Attendance} 
    'Style'.     : {Style}
    'WIP'        : {WIP} 

Are you satisfied with this?'''

def worker_wip(machine_code):
	### This needs to be updated to reflect the fact that the worker_id task will now deal with the issue
	### of machines being manned (operator present) or unmanned (operator absent or otherwise not there). 
    """ Function to create individual machine WIP dict """

    console.clear()
    print('For machine {} please enter thee following information: \n'.format(machine_code))

    # Machine wip dictionary
    machine_dict = { 'Attendance' : 'Absent', #The attendance no longer necessary once the ID number routine complete
					 'Style'.     : 'null',
					 'WIP'        : 'null' }
    # Determine absence
    user_choice = get_user_choice_text('{} : Is the operator present?'.format(machine_code), 
	                                    ('Please select an option', 'Present', 'Absent',))
    # If operator not present
    if user_choice != 'Present':
         print wip_validation_fmt.format(machine_code, **machine_dict)  # print data back to user
         time.sleep(2)

		#check user satisfaction
		user_satisfied = get_user_choice_text('Are you satisfied with data entered?',
                                             ('Select one', 'Yes', 'No'))
		if user_satisfied == 'No':
			return worker_wip(machine_code)  # re-enter worker wip data

		return machine_dict  # return the worker wip dict

    # !!! THE FOLLOWING CODE WILL NEVER GET EXECUTED !!!
	# RC in the version I was working on the indentations above were correct (I have now corrected them here also).
	# I must have accidentally changed them.
	
    # If operator present
    machine_dict['Attendance'] ='Present'
    prompt = 'Please enter current style name/number as per work order: '
    machine_dict['Style'] = get_user_input(prompt).strip().lower()
    prompt = 'Please enter the amount of WIP at time of checking: '
    machine_dict['WIP'] = get_user_Sfloat(prompt)

    print wip_validation_fmt.format(machine_code, **machine_dict) # print data back to user
    time.sleep(4)
	
    user_satisfied = get_user_choice_text('Are you satisfied with data entered?', 
	                                       ('Select one', 'Yes', 'No'))
    if user_satisfied == 'No':
        return worker_wip(machine_code) #re-enter worker wip data
	
    return machine_dict #return the worker wip dict

def wip_task(task_tuple, top_level_dict, task_data_dict):
    """ Updates relevant wip data dictionary """

    task_data_dict['date_time'].append(get_timestamp())
    department = task_tuple[0].split('_')[0]
    for machine_code in create_machine_code(top_level_dict, department):
        worker_wip_dict = worker_wip(machine_code)
        for data_point in task_data_dict[machine_code]:
            task_data_dict[machine_code][data_point].append(worker_wip_dict[data_point])

    return task_data_dict

def interact_task():
    # complete once defined
    print('TBC')
    return

def other_task():
    # complete once defined
    print 'TBC'
    return

def initiate_task(task_tuple, task_function_dict):
    task = task_tuple[0].split('_')[1]
    return task_function_dict[task][0](*task_function_dict[task][1])
	
def get_user_photo():
	''' Prompts the user to take an image and returns the image. The user may not cancel'''
	user_photo = photos.capture_image()
	if user_photo is None:
		Error = 'You may not cancel the photograph at this time'
		console.hud_alert(Error, 'error')
		return get_user_image()
	return user_photo
	
def save_user_photo(photo, task_name):
	''' Saves user photo with timestamp and name related to the task '''
	time_stamp = get_timestamp()
	file_name = task_name + time_stamp + '.jpeg'
	photo.save(file_name)
	

###########################################################################################################
#Run the program
<<<<<<< HEAD
console.clear()
print 'Welcome to RMG Observations'
top_level_dict = open_json('top_level_data.json', configure_application, ('top_level_data.json',))
today_knitting_id_dict = id_daily_routine('Knitting', top_level_dict)
today_linking_id_dict = id_daily_routine('Linking', top_level_dict)
past_knitting_id_file_name = locate_most_recent



task_tuple = determine_task()
task_file_name = task_dict[task_tuple][0]
task_data_dict = open_json(task_file_name, None, None)

task_function_dict = {'wip'.     : (wip_task, (task_tuple, top_level_dict, task_data_dict)),
                      'interact' : (interact_task, (())),
                      'other'    : (other_task, (())) }

modified_task_dict = initiate_task(task_tuple, task_function_dict)
write_to_json(modified_task_dict, task_file_name)
save_user_photo(get_user_photo(), task_tuple[0])

=======
>>>>>>> 9542f3cd86c99af7ccdace3de292e2b377dd1191
def main(argv):
    console.clear()
    print 'Welcome to RMG Observations'
    top_level_dict = open_json('top_level_data.json', configure_application, ('top_level_data.json',))
	today_knitting_id_dict = id_daily_routine('Knitting', top_level_dict)
	today_linking_id_dict = id_daily_routine('Linking', top_level_dict)
    task_tuple = determine_task()
    task_file_name = task_dict[task_tuple][0]
    task_data_dict = open_json(task_file_name, None, None)

    task_function_dict = {'wip'.     : (wip_task, (task_tuple, top_level_dict, task_data_dict)),
                          'interact' : (interact_task, (())),
                           'other'   : (other_task, (())) }
    modified_task_dict = initiate_task(task_tuple, task_function_dict)
    write_to_json(modified_task_dict, task_file_name)
	save_user_photo(get_user_photo(), task_tuple[0])

	'''
	see: http://docs.python.org/2/tutorial/modules.html#executing-modules-as-scripts
	'''

if __name__ == '__main__':
    sys.exit(main(sys.argv))
